#include <WiFi.h>
#include <WiFiClient.h>
#include <esp32-hal-log.h>
#include <driver/gpio.h>
#include <esp_camera.h>
#include <SD_MMC.h>

#define WIFI_SSID "RNGesus"
#define WIFI_PASSWORD "computer"
#define SERVER_ADDRESS "192.168.18.143"
#define SERVER_PORT 8888

#define SD_CS_PIN 5 // Used with SD Card

#define TIMEOUT_MS 5000
#define HANDSHAKE_MESSAGE "HSK_L"
#define HANDSHAKE_RESPONSE "ACK_L"
#define HANDSHAKE_COMPLETE "RDY_L"
#define BUFFER_SIZE 1024
#define TIMESTAMP_SIZE 20

#define COMMAND_SIZE 1024

#define LOOP_DELAY_MS 1000      // delay between loops in milliseconds
#define RECONNECT_DELAY_MS 5000 // delay before attempting to reconnect in milliseconds

//===================== COMMANDS ===========================//
#define SCAN "SCAN"
#define RECEIVE "FRAME"

enum modes
{
    SINGLE,
    BURST,
    TIME
};

String server_buf; // Whatever we receive from server, we store here
int server_sz = 0; // We store the length of server message here
String client_buf; // Whatever we send to server from client, we store here
int client_sz = 0; // We store the length of client message here

char date_time[TIMESTAMP_SIZE] = {0}; // The server will send the date and time only once and we will store in this variable

WiFiClient client; // The object which handles the WiFi

File pictureFile;

void setupSDCard()
{
    pinMode(13, INPUT_PULLUP);
    if (!SD_MMC.begin("/Images/", true))
    {
        Serial.println("Error initializing SD card");
    }
}

// Send a message to the server and wait for a response
bool handshake()
{
    char buffer[BUFFER_SIZE] = {0};
    int bytes_received = 0;
    int total_bytes_received = 0;
    int send_result = 0;

    // Send the handshake message to the server
    send_result = client.write(HANDSHAKE_MESSAGE, strlen(HANDSHAKE_MESSAGE));
    if (send_result < 0)
    {
        Serial.println("Handshake message failed to send");
        return false;
    }
    Serial.println("Handshake sent to server");

    // Receive the acknowledgement from the server
    do
    {
        bytes_received = client.readBytes(buffer + total_bytes_received, BUFFER_SIZE - total_bytes_received);
        if (bytes_received < 0)
        {
            Serial.println("Failed to receive message from server");
            break;
        }
        total_bytes_received += bytes_received;
    } while (bytes_received > 0);

    // Check if the response is valid
    if (strcmp(buffer, HANDSHAKE_RESPONSE) == 0)
    {
        Serial.println("Acknowledgement received from server");
    }
    else
    {
        Serial.printf("Invalid response from server: %s\n", buffer);
        return false;
    }

    // Send Ready flag to server
    send_result = client.write(HANDSHAKE_COMPLETE, strlen(HANDSHAKE_COMPLETE));
    if (send_result < 0)
    {
        Serial.println("Handshake complete message failed to send");
        return false;
    }
    Serial.println("Handshake successful with server");

    return true;
}

bool getDateAndTime()
{
    int bytes_received = 0;
    int total_bytes_received = 0;

    // Receive the date and time string from the server
    do
    {
        bytes_received = client.readBytes(date_time + total_bytes_received, TIMESTAMP_SIZE - total_bytes_received);
        if (bytes_received < 0)
        {
            Serial.println("Failed to receive date and time string from server");
            return false;
        }
        total_bytes_received += bytes_received;
    } while (bytes_received > 0);

    // Print the date and time string to the serial console
    Serial.print("Date and Time: ");
    Serial.println(date_time);
    return true;
}

void connectToWiFi()
{
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
    Serial.print("Connecting to WiFi");
    while (WiFi.status() != WL_CONNECTED)
    {
        delay(1000);
        Serial.print(".");
    }
    Serial.println("WiFi connected");
}

// Connect to Server
void connectToServer()
{
    client.connect(SERVER_ADDRESS, SERVER_PORT);

    // Handshake Protocol
    bool hand_flag = handshake();

    if (!hand_flag)
    {
        Serial.println("Handshake was not successful");
    }

    // Synchronize time
    bool time_flag = getDateAndTime();

    if (!time_flag)
    {
        Serial.println("Time&Date was not attained");
    }

    Serial.println("All checks passed....");
}

bool initCamera()
{
    // Initialize camera
    camera_config_t config;
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = 5;
    config.pin_d1 = 18;
    config.pin_d2 = 19;
    config.pin_d3 = 21;
    config.pin_d4 = 36;
    config.pin_d5 = 39;
    config.pin_d6 = 34;
    config.pin_d7 = 35;
    config.pin_xclk = 0;
    config.pin_pclk = 22;
    config.pin_vsync = 25;
    config.pin_href = 23;
    config.pin_sscb_sda = 26;
    config.pin_sscb_scl = 27;
    config.pin_pwdn = 32;
    config.pin_reset = -1;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;

    config.frame_size = FRAMESIZE_SVGA;
    config.jpeg_quality = 90;
    config.fb_count = 2;

    // Start camera
    esp_err_t err = esp_camera_init(&config);
    if (err != ESP_OK)
    {
        Serial.printf("Camera init failed with error 0x%x", err);
        return false;
    }
    return true;
}

bool capturePhotoAndSave(String path)
{

    if (SD_MMC.exists("/Images/" + path + ".jpeg"))
    {
        Serial.println("File already exists, deleting...");
        if (!SD_MMC.remove("/Images/" + path + ".jpeg"))
        {
            Serial.println("Error deleting file");
            return false;
        }
    }

    pictureFile = SD_MMC.open("/Images/" + path + ".jpeg", FILE_WRITE);
    if (!pictureFile)
    {
        Serial.println("Error opening file for writing");
        return false;
    }

    // Take picture
    camera_fb_t *picture = esp_camera_fb_get();
    if (!picture)
    {
        Serial.println("Failed to take picture");
        return false;
    }

    // Save picture to SD card
    if (!pictureFile.write(picture->buf, picture->len))
    {
        Serial.println("Failed to save picture to SD card");
        return false;
    }

    pictureFile.close();
    esp_camera_fb_return(picture);

    Serial.println("Picture taken and saved to SD card");
    return true;
}

bool sendPhotosToServer()
{
    return true;
}

bool processCommand(const String &cmd)
{
    if (cmd == "SCAN")
    {
        // Take photo and save to SD_CARD, we can also pass the path as an argument
        return capturePhotoAndSave("test");
    }
    else if (cmd == "ACQUIRE")
    {
        // Send the photos from esp32 ai thinker to server,by dequeuing
        sendPhotosToServer();
        return true;
    }
    Serial.println("The command passed was not correct");
    return false;
}